<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Cesium Viewer</title>

    <!-- CesiumJS CSS -->
    <link href="./Build/Cesium/Widgets/widgets.css" rel="stylesheet" />

    <!-- CesiumJS Script -->
    <script src="./Build/Cesium/Cesium.js"></script>

    <script src="./auth.js"></script>

    <script src="./wrapper.js"></script>
    <!-- Custom Styles -->
    <style>
      html,
      body,
      #cesiumContainer {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      #loadingOverlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(42, 42, 42, 0.8);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        font-size: 2em;
      }

      #toolbar {
        position: absolute;
        top: 80px;
        left: 10px;
        background: rgba(42, 42, 42, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 20;
      }

      button {
        margin: 5px;
        padding: 5px 10px;
        background: #444;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 3px;
      }
      #toolbar1 {
        position: absolute;
        top: 80px;
        left: 10px;
        background: rgba(42, 42, 42, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 20;
        color: aliceblue;
      }

      #toolbar button {
        margin: 5px;
        padding: 5px 10px;
        background: #444;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 3px;
      }

      #toolbar button:hover {
        background: #666;
      }

      #toolbar1 button {
        margin: 5px;
        padding: 5px 10px;
        background: #444;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 3px;
      }

      #toolbar1 button:hover {
        background: #666;
      }

      #toolbar2 {
        color: white;
        position: absolute;
        top: 80px;
        left: 10px;
        background: rgba(42, 42, 42, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 20;
      }

      #toolbar2 button {
        margin: 5px;
        padding: 5px 10px;
        background: #444;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 3px;
      }

      #toolbar2 button:hover {
        background: #666;
      }

      .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 34px;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: #2196f3;
      }

      input:checked + .slider:before {
        transform: translateX(26px);
      }
    </style>
  </head>

  <body>
    <div id="cesiumContainer"></div>
    <div id="loadingOverlay">
      <h1>Loading...</h1>
    </div>

    <div
      id="toolbarSelector"
      style="
        position: absolute;
        top: 10px;
        left: 20px;
        z-index: 30;
        background: rgba(42, 42, 42, 0.7);
        padding: 10px;
      "
    >
      <label for="toolbarSelect" style="color: white">Select Toolbar: </label>
      <select id="toolbarSelect">
        <option value="">-- Choose --</option>
        <option value="toolbar">RMQ</option>
        <option value="toolbar1">VPS</option>
        <option value="toolbar2">POI</option>
        <option value="MapAligner">Map Aligner</option>
      </select>
    </div>
    <div id="MapAligner" style="color: white;
    position: absolute;
    top: 80px;
    left: 10px;
    background: rgba(42, 42, 42, 0.7);
    padding: 10px;
    border-radius: 5px;
    z-index: 20;">

  <h3>Map Aligner</h3>

  <!-- Model Upload -->
  <input type="file" id="modelFileInput" accept=".glb,.gltf,.obj" />
  <br />
  <input type="text" placeholder="3D Model URL" id="modelUrl" />
  <button onclick="loadModelFromURL()">Load from URL</button>
  <br /><br />
  <div id="coordinatesText"></div>
  <br />
  <input type="checkbox" id="coordinateToggle" />
  <label for="coordinateToggle">Enable to choose coordinates from click</label>
  <br /><br />
  <button id="sendBtn" onclick="saveMatrix()">Save Data</button>
  <br /><br />
  <!-- Model Controls -->
  <label for="modelScale"><strong>Scale:</strong></label>
  <input type="number" id="modelScale" value="1" min="0.1" step="0.1" style="width:70px;">
  <br /><br />
  <label for="positionStep"><strong>Position step (° lat/lon):</strong></label>
  <input type="number" id="positionStep" value="10" min="0.1" step="1" style="width:80px;">*e-6
  <br /><br />
  <label for="heightStep"><strong>Height step (m):</strong></label>
  <input type="number" id="heightStep" value="1" min="0.01" step="0.01" style="width:70px;">
  <br /><br />
  <button onclick="moveModel('up')">UP ↑</button>
  <button onclick="moveModel('down')">DOWN ↓</button>
  <br />
  <button onclick="moveModel('west')">WEST ←</button>
  <button onclick="moveModel('east')">EAST →</button>
  <br />
  <button onclick="moveModel('north')">NORTH ⤴</button>
  <button onclick="moveModel('south')">SOUTH ⤵</button>
  <br /><br />
  <label for="rotationStep"><strong>Rotation step size:</strong></label>
  <input type="number" id="rotationStep" value="5" min="0.1" max="90" step="0.1" style="width:60px;">°
  <br /><br />
  <button onclick="rotateModel('left')">⟲ Yaw Left</button>
  <button onclick="rotateModel('right')">⟳ Yaw Right</button>
  <br />
  <button onclick="adjustPitch('up')">Pitch ↑</button>
  <button onclick="adjustPitch('down')">Pitch ↓</button>
  <br />
  <button onclick="adjustRoll('left')">Roll ←</button>
  <button onclick="adjustRoll('right')">Roll →</button>
  <br /><br />
  <button onclick="exportModelMatrix()">Export Matrix JSON</button>
  <br /><br />
  <button id="loginBtn" onclick="login()">Login</button>
  <button id="logoutBtn" onclick="logout()" style="display:none">Logout</button>
  </div>
    <div
      id="baseToggle"
      style="
        position: absolute;
        top: 10px;
        left: 250px;
        z-index: 30;
        background: rgba(42, 42, 42, 0.7);
        padding: 8px;
        border-radius: 5px;
        color: white;
      "
    >
      <input type="checkbox" id="myToggle" />
      <label for="myToggle">Load defaults</label>
    </div>

    <div
      id="flyToCoordinate"
      style="
        position: absolute;
        top: 10px;
        left: 400px;
        z-index: 30;
        background: rgba(42, 42, 42, 0.7);
        padding: 10px;
      "
    >
      <input type="text" placeholder="Latitude" id="latitude" />
      <input type="text" placeholder="Longitude" id="longitude" />
      <button onclick="Go()">Go</button>
    </div>

    <div
      id="base"
      style="
        position: absolute;
        top: 10px;
        left: 840px;
        z-index: 30;
        background: rgba(42, 42, 42, 0.7);
        padding: 8px;
        border-radius: 5px;
        color: white;
      "
    >
      <button onclick="Corvin()">Corvin</button>
      <button onclick="Aalto()">Aalto</button>
    </div>
    <div id="toolbar">
      <input
        type="file"
        id="fileInput"
        accept="image/*"
        style="display: none"
      />
      <input type="text" placeholder="user" id="rmquser" />
      <input type="password" placeholder="password" id="rmqpassword" />
      <input type="text" placeholder="url" id="rmqurl" />
      <input type="text" placeholder="subscribe" id="rmqtopic_geopose_update" />
      <input type="number" placeholder="height" id="rmqheight" />
      <button onclick="connectRMQ()">Connect</button>
      <label class="switch">
        <input type="checkbox" id="toggleSwitch" />
        <span class="slider round"></span>
      </label>
      <span
        id="toggleLabel"
        style="
          margin-left: 10px;
          font-family: sans-serif;
          color: rgb(255, 255, 255);
          padding: 10px;
        "
      >
        Send Waypoint
      </span>
      <input type="text" placeholder="RMQ Send" id="rmqtopic_waypoint" />
    </div>
    <div id="toolbar1">
      <button id="selectImageBtn">Choose Image</button>
      <input type="text" placeholder="VPS URL" id="vpsurl" />
      <input type="number" placeholder="height" id="vpsheight" />
      <span
        id="vpsLabel"
        style="
          margin-left: 10px;
          font-family: sans-serif;
          color: rgb(255, 255, 255);
          padding: 10px;
        "
      >
        Ground Level (m)
      </span>
      <button onclick="Localize()">Localize</button>
      <div id="statusText"></div>
    </div>
    <div id="toolbar2">
      <input type="text" placeholder="POI URL" id="poiurl" />
      <input type="text" placeholder="Query" id="query" />
      <button onclick="searchForPOIS()">Search</button>
      <div id="poiSearchText"></div>
    </div>

    <canvas id="canvas"></canvas>
    <script type="module">
      let CreativeModeEnabled = false;
      let clientActivationEnabled = true;
      let messageFromSparcl = undefined;
      let duck;
      let rmqClient;
      let PoiText = document.getElementById("poiSearchText");
      PoiText.textContent = `Chosen coordinates: Lat: 0, Lon: 0, Height: 0`;
      let poiLat = 0;
      let poiLon = 0;
      let poiHeight = 0;

      //TOKENS------------
      const CesiumToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI0ZGIyMGE3NC03NmUxLTRlNjQtYTE3Ny1mNzQwOGI0YTM1NzgiLCJpZCI6Mjk0MDAxLCJpYXQiOjE3NDQ2Mzk3ODR9.K68s7FUXRHCwRn8L4UZQFQHzDfO3RmikQmRcDbgY6Jo";
      const tileID = 2275207;
      //------------------

      import { getTransform, postTransform } from "./wrapper.js";
      import { login, logout, handleRedirect, getUserInfo } from "./auth.js";
      import { v4 as uuidv4 } from "uuid";
      import {
        CesiumWidget,
        Terrain,
        createGooglePhotorealistic3DTileset,
        Math,
        Cartesian2,
        Cartesian3,
        HeadingPitchRoll,
        Transforms,
        Matrix4,
        ParticleSystem,
        CircleEmitter,
        ParticleBurst,
        ConeEmitter,
        Color,
        ClockRange,
        JulianDate,
        PolygonHierarchy,
        Ion,
      } from "./Build/Cesium/index.js";
      import {
        sendRequest,
        validateRequest,
        GeoPoseRequest,
        Sensor,
        Privacy,
        ImageOrientation,
        IMAGEFORMAT,
        CameraParam,
        CAMERAMODEL,
        SENSORTYPE,
      } from "@oarc/gpp-access";
      import { Client } from "@stomp/stompjs";
      import ExifReader from "exifreader";
      import qte from "quaternion-to-euler";

      const selectBtn = document.getElementById("selectImageBtn");
      const fileInput = document.getElementById("fileInput");
      const output = document.getElementById("base64Output");

      let connectionDetails;
      let mapLatitude = 0;
      let mapLongitude = 0;
      let mapHeight = 0;

      fetch("connect.json")
        .then((response) => response.json())
        .then((data) => {
          connectionDetails = data;
        })
        .catch((error) => console.error("Error loading JSON:", error));

      let baseConnected = false;
      const toggle = document.getElementById("myToggle");
      toggle.addEventListener("change", function () {
        baseConnected = this.checked;
        console.log("Base toggle state:", baseConnected);
        if (!connectionDetails) {
          console.log("Error: no config.json was found");
          return;
        }});
      
      let chooseCoordinatesEnable = false;
      const coordinateToggle = document.getElementById("coordinateToggle");
      coordinateToggle.addEventListener("change", function () {
        chooseCoordinatesEnable = this.checked;
        console.log("Choose coordinates by click:", chooseCoordinatesEnable);

        if (baseConnected) {
          document.getElementById("rmqurl").value = connectionDetails.rmqurl;
          document.getElementById("rmquser").value = connectionDetails.rmquser;
          document.getElementById("rmqpassword").value = connectionDetails.rmqpassword;
          document.getElementById("rmqtopic_geopose_update").value = connectionDetails.rmqtopic_geopose_update;
          document.getElementById("rmqtopic_waypoint").value = connectionDetails.rmqtopic_waypoint;
          document.getElementById("poiurl").value = connectionDetails.poiurl;
          document.getElementById("vpsurl").value = connectionDetails.vpsurl;
        }
      });

      function connectRMQ() {
        rmqClient = new Client({
          brokerURL: document.getElementById("rmqurl").value,
          connectHeaders: {
            login: document.getElementById("rmquser").value,
            passcode: document.getElementById("rmqpassword").value,
          },
          debug: (str) => console.log("STOMP:", str),
          onConnect: () => {
            console.log("Connected!");

            rmqClient.subscribe(
              document.getElementById("rmqtopic_geopose_update").value,
              (message) => {
                const RMQmessage = JSON.parse(message.body);
                updatePosition(RMQmessage);
              }
            );
          },
          onStompError: (frame) => {
            console.error("STOMP error:", frame.headers["message"]);
            console.error("Details:", frame.body);
          },
        });
        rmqClient.activate();
      }

      selectBtn.addEventListener("click", () => {
        fileInput.click();
      });

      async function Localize() {
        try {
          if (!canvas || !imageFile) {
            console.log("No image selected yet.");
            return;
          }

          const base64String = canvas.toDataURL("image/jpeg");
          const intrinsics = await getCameraIntrinsics(
            imageFile,
            targetWidth,
            targetHeight
          );
          console.log("EXIF Intrinsics: ", intrinsics)
          if (intrinsics === null) {
            alert(`Could not read camera intrinsics from the image! Please select an image with EXIF information`);
            return;
          }

          let cameraParams = new CameraParam();
          cameraParams.model = CAMERAMODEL.PINHOLE;
          cameraParams.modelParams = [
            intrinsics.fx,
            intrinsics.fy,
            intrinsics.cx,
            intrinsics.cy,
          ];

          const geolocationInfo = await getGeolocationInfo(imageFile);
          console.log("EXIF Geolocation: ", geolocationInfo)
          if (geolocationInfo === null) {
            alert(`Could not read geolocation from the image! Please select an image with EXIF information`);
            return;
          }

          fileInput.value = ""; // clear file input

          // See https://github.com/OpenArCloud/gpp-access/blob/main/lib/request/GeoPoseRequest.ts
          const geoPoseRequest = new GeoPoseRequest(uuidv4());
          geoPoseRequest
            .addSensor(new Sensor("myCamera", SENSORTYPE.camera))
            .addCameraData(
              IMAGEFORMAT.JPG,
              [targetWidth, targetHeight],
              base64String.split(",")[1],
              0,
              new ImageOrientation(false, 0),
              cameraParams,
              new Date().getTime(),
              "myCamera",
              new Privacy()
            )
            .addSensor(new Sensor("myGps", SENSORTYPE.geolocation))
            .addGeoLocationData(
              geolocationInfo.lat, // latAngle
              geolocationInfo.lon, // lonAngle
              geolocationInfo.h, // alt
              0, // accuracy
              0, // altAccuracy
              0, // heading
              0, // speed
              geolocationInfo.timestamp, // timestamp
              "myGps", // sensorId
              new Privacy() // privacy
            );

          // TODO: the camera timestamp should be read from the EXIF
          // read the DateTimeOriginal and OffsetTime tags, and then converted to posixTimeMillis

          sendRequest(
            document.getElementById("vpsurl").value,
            JSON.stringify(geoPoseRequest)
          )
            .then((data) => {
              try {
                console.log(data);
                const statusDiv = document.getElementById("statusText");
                const lat = data.geopose.position.lat;
                const lon = data.geopose.position.lon;
                let height = data.geopose.position.h;
                const x = data.geopose.quaternion.x;
                const y = data.geopose.quaternion.y;
                const z = data.geopose.quaternion.z;
                const w = data.geopose.quaternion.w;

                const orientation = Cesium.HeadingPitchRoll.fromQuaternion(
                  new Cesium.Quaternion(x, y, z, w)
                );
                const heading = Cesium.Math.toDegrees(orientation.heading);
                const pitch = Cesium.Math.toDegrees(orientation.pitch);
                const roll = Cesium.Math.toDegrees(orientation.roll);

                let givenHeight =
                  parseFloat(document.getElementById("vpsheight").value) +
                  parseFloat(height);
                if (!givenHeight) {
                  givenHeight = 0;
                }

                statusDiv.textContent =
                  `Latitude: ${lat.toFixed(5)}, Longitude: ${lon.toFixed(
                    5
                  )}, ` +
                  `Height: ${height.toFixed(2)} m, Heading: ${heading.toFixed(
                    2
                  )}°, ` +
                  `Pitch: ${pitch.toFixed(2)}°, Roll: ${roll.toFixed(2)}°`;

                flyToImagePose(lat, lon, givenHeight, x, y, z, w);
              } catch {
                console.log("Could not parse VPS response");
              }
            })
            .catch((err) => {
              console.log("Wrong VPS address or VPS error:", err);
              const statusDiv = document.getElementById("statusText");
              statusDiv.textContent = "Wrong VPS address or VPS error";
            });
        } catch (err) {
          console.log("Could not send localization request due to error: ", err);
        }
      }

      //Image parameters
      let imageFile; // the raw file
      let imageElement; // the Image() object
      let canvas; // the drawing canvas
      let ctx; // canvas context
      let targetWidth;
      let targetHeight;
      let base64Image; // base64 string

      fileInput.addEventListener("change", () => {
        imageFile = fileInput.files[0]; // assign globally
        if (!imageFile) return;

        imageElement = new Image(); // assign globally
        const reader = new FileReader();
        canvas = document.createElement("canvas"); // assign globally
        ctx = canvas.getContext("2d");

        reader.onload = function (e) {
          imageElement.onload = async function () {
            const width = imageElement.width;
            const height = imageElement.height;
            base64Image = e.target.result; // assign globally

            // Maintaining aspect ratio
            const aspectRatio = width / height;
            targetHeight = 1024;
            targetWidth = 1024 * aspectRatio;

            canvas.width = targetWidth;
            canvas.height = targetHeight;
            ctx.drawImage(imageElement, 0, 0, targetWidth, targetHeight);

            console.log("Image ready:", {
              imageFile,
              targetWidth,
              targetHeight,
              base64Image,
            });
          };

          imageElement.src = e.target.result;
        };

        reader.readAsDataURL(imageFile);
      });

      // Replace this with your actual Cesium Ion access token
      Cesium.Ion.defaultAccessToken = CesiumToken;

      const viewer = new Cesium.Viewer("cesiumContainer", {
        globe: false,
        // shadows: true,
        shouldAnimate: true,
        geocoder: Cesium.IonGeocodeProviderType.GOOGLE,
        //terrainProvider: Cesium.Terrain.fromWorldTerrain(),
      });
      viewer.camera.frustum.fov = Cesium.Math.toRadians(110);

      document
        .getElementById("toggleSwitch")
        .addEventListener("change", function () {
          CreativeModeEnabled = this.checked;
        });

      function convertDMSToDD(degrees, minutes, seconds, direction) {
        let dd = degrees + minutes / 60 + seconds / (60 * 60);
        if (direction === "S" || direction === "W") {
          dd = dd * -1;
        }
        // Don't do anything for N or E

        //console.log("convertDMSToDD")
        //console.log("  degrees: ", degrees)
        //console.log("  minutes: ", minutes)
        //console.log("  seconds: ", seconds)
        //console.log("  direction: ", direction)
        //console.log("  output: ", dd)
        return dd;
      }

      async function getGeolocationInfo(file) {
        // TODO: https://github.com/MikeKovarik/exifr seems significantly easier to use
        try {
          let geolocationData = null;
          await ExifReader.load(file || url, { async: true }).then(function (tags) {
            // See all tags here: https://exiftool.org/TagNames/GPS.html
            //console.log(tags);

            const gpsLatitudeRef = tags["GPSLatitudeRef"].value[0]; // N or S
            const gpsLatitudeDMS = tags["GPSLatitude"].value;
            // GPSLatitude value is a 3-array of [degrees, minutes, seconds], where each of them is a rational in form [num, denom]
            // but the description is a single float
            const latitude = convertDMSToDD(
              gpsLatitudeDMS[0][0] / gpsLatitudeDMS[0][1],
              gpsLatitudeDMS[1][0] / gpsLatitudeDMS[1][1],
              gpsLatitudeDMS[2][0] / gpsLatitudeDMS[2][1],
              gpsLatitudeRef
            );
            //const latitude = tags["GPSLatitude"].description
            const gpsLongitudeRef = tags["GPSLongitudeRef"].value[0]; // E or W
            const gpsLongitudeDMS = tags["GPSLongitude"].value;
            // GPSLongitude value is a 3-array of [degrees, minutes, seconds], where each of them is a rational in form [num, denom]
            // but the description is a single float
            const longitude = convertDMSToDD(
              gpsLongitudeDMS[0][0] / gpsLongitudeDMS[0][1],
              gpsLongitudeDMS[1][0] / gpsLongitudeDMS[1][1],
              gpsLongitudeDMS[2][0] / gpsLongitudeDMS[2][1],
              gpsLongitudeRef
            );
            //const longitude = tags["GPSLongitude"].description;

            const gpsAltitudeRef = tags["GPSAltitudeRef"].value;
            // GPSAltitudeRef value is an integer between 0 and 3
            // 0 = Above Sea Level, 1 = Below Sea Level,
            // 2 = Positive Sea Level (sea-level ref), 3 = Negative Sea Level (sea-level ref)
            let gpsAltitude = tags["GPSAltitude"].value[0] / tags["GPSAltitude"].value[1];
            // GPSAltutude value is a rational in form [num, denom]
            if (gpsAltitudeRef == 1 || gpsAltitudeRef == 3) {
              gpsAltitude = gpsAltitude * -1;
            }
            // WARNING: GeoPose uses height above WGS84 ellipsoid, not sea level -- we are introducing an error here
            // we should look up in some GIS database the difference between ellipsoidheight and sea level height at the given location

            const gpsImgDirectionRef = tags["GPSImgDirectionRef"].value[0] // 'M' = Magnetic North, 'T' = True North
            let gpsImgDirection = tags["GPSImgDirection"].value[0] / tags["GPSImgDirection"].value[1]
            //GPSImgDirection value is a rational in form [num, denom]
            //gpsImgDirection = (90 + gpsImgDirection) % 360
            // WARNING: the GeoPose standard measures camera orientation w.r.t East and not North! So we need to add 90 degrees offset.

            const gpsDateStampString = String(tags["GPSDateStamp"].value) // string in form "YYYY:mm:dd"
            const year = gpsDateStampString.split(':')[0]
            const month = gpsDateStampString.split(':')[1]
            const day = gpsDateStampString.split(':')[2]
            const gpsTimestampArray = tags["GPSTimeStamp"].value // UTC time in form of rational 3-array [H, M, S]
            const hour = String(gpsTimestampArray[0][0] / gpsTimestampArray[0][1]).padStart(2, "0");
            const minute = String(gpsTimestampArray[1][0] / gpsTimestampArray[1][1]).padStart(2, "0");
            const second = String(gpsTimestampArray[2][0] / gpsTimestampArray[2][1]).padStart(2, "0");
            const dateString = `${year}-${month}-${day}T${hour}:${minute}:${second}`;
            console.log(dateString)
            const date = new Date(dateString);
            const posixTimeMillis = date.getTime();
            console.log(posixTimeMillis);

            geolocationData = {
              lat: latitude,
              lon: longitude,
              h: gpsAltitude, // TODO: send ellipsoid height instead of sea level height?
              heading: gpsImgDirection, // TODO: add 90deg offset or not?
              timestamp: posixTimeMillis
            };
          });
          return geolocationData;
        } catch (error) {
          console.log(`Could not get geolocation from EXIF of photo: ${error}`);
          return null;
        }
      }

      async function getCameraIntrinsics(file, width, height) {
        const ratio = width / height;
        let sensorWidth;
        let sensorHeight;
        if (ratio >= 1) {
          sensorWidth = 35;
          sensorHeight = 35 / ratio;
        } else {
          sensorHeight = 35;
          sensorWidth = 35 * ratio;
        }
        try {
          let focalLength;
          await ExifReader.load(file || url, { async: true }).then(function (tags) {
            // See https://exiftool.org/TagNames/EXIF.html
            focalLength = tags["FocalLengthIn35mmFilm"].value;
          });

          const fx = (focalLength / sensorWidth) * width;
          const fy = (focalLength / sensorHeight) * height;
          const cx = width / 2;
          const cy = height / 2;

          const intrinsics = {
            fx: fx,
            fy: fy,
            cx: cx,
            cy: cy,
          };
          return intrinsics;
        } catch (error) {
          console.log(`Could not get camera intrinsics from EXIF of photo" ${error}`);
          return null;
        }
      }

      async function getTileset() {
        try {
          const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(tileID, {
            enableCollision: true,
          });
          viewer.scene.primitives.add(tileset);
          document.getElementById("loadingOverlay").style.display = "none";
        } catch (error) {
          alert(`Error loading 3D Tiles tileset: ${error}`);
        }
      }

      // Set up mouse click handler
      const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

      handler.setInputAction(function (click) {
        const pickedPosition = viewer.scene.pickPosition(click.position);
        const cartographic = Cesium.Cartographic.fromCartesian(pickedPosition);
        const lat = Cesium.Math.toDegrees(cartographic.latitude);
        const lon = Cesium.Math.toDegrees(cartographic.longitude);
        const height = cartographic.height;
        if(chooseCoordinatesEnable){
        mapHeight = height;
        mapLatitude = lat;
        mapLongitude = lon;

        const coordinatesText = document.getElementById("coordinatesText");
        coordinatesText.textContent = `Chosen coordinates: Lat: ${lat.toFixed(
          5
        )}, Lon: ${lon.toFixed(5)}, Height: ${height.toFixed(2)}`;
        }
        const statusDiv = document.getElementById("poiSearchText");
        statusDiv.textContent = `Chosen coordinates: Lat: ${lat.toFixed(
          5
        )}, Lon: ${lon.toFixed(5)}, Height: ${height.toFixed(2)}`;
        poiLat = lat;
        poiLon = lon;
        poiHeight = height;

        if (Cesium.defined(pickedPosition)) {
          if (CreativeModeEnabled) {
            removeEntityWithName("mapPinCreative");
            if (agents.length > 0) {
              for (let i = 0; i < agents.length; i++) {
                rmqClient.publish({
                  destination:
                    document.getElementById("rmqtopic_waypoint").value,
                  body: JSON.stringify({
                    active: true,
                    creator_id: "Cesium",
                    agent_id: agents[i].name,
                    geopose: {
                      position: {
                        lat: lat,
                        lon: lon,
                        h: 0,
                      },
                      quaternion: {
                        x: 0,
                        y: 0,
                        z: 0,
                        w: 1,
                      },
                    },
                  }),
                });
                console.log("Message sent.");
              }
            }
            viewer.entities.add({
              name: "mapPinCreative",
              position: Cesium.Cartesian3.fromDegrees(lon, lat, 2),
              model: {
                uri: "./models/pin.glb",
                heightReference: Cesium.HeightReference.RELATIVE_TO_3D_TILE,
              },
            });

            console.log(
              `Clicked position:\nLatitude: ${lat}\nLongitude: ${lon}\nHeight: ${height}`
            );
          }
        } else {
          console.warn(
            "No surface picked — try clicking on a visible 3D surface."
          );
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      await getTileset();
      viewer.scene.skyAtmosphere.show = true;

      async function callAPI(poiUrl, lat, lng, keyword) {
        let url =
          poiUrl + "?lat=" + lat + "&lng=" + lng + "&textQuery=" + keyword;
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();

        return data.features;
      }

      function Go() {
        let lat = document.getElementById("latitude").value;
        let lon = document.getElementById("longitude").value;
        if (!lat || !lon) {
          console.log("No coordinates given");
          return;
        }
        viewer.scene.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(lon, lat, 50),
          duration: 3,
        });
      }

      function flyToImagePose(lat, lon, height, x, y, z, w) {
        let quaternion = new Cesium.Quaternion(x, y, z, w);
        let cameraOrientation =
          Cesium.HeadingPitchRoll.fromQuaternion(quaternion);
        cameraOrientation.heading += 1.5707963267948966192;
        viewer.scene.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(lon, lat, height),
          //orientation: cameraOrientation,
          orientation: cameraOrientation,
          duration: 3,
        });
      }

      async function searchForPOIS() {
        removeEntityWithName("mapPin");
        let url = document.getElementById("poiurl").value;
        let query = document.getElementById("query").value;
        try {
          let places = await callAPI(url, poiLat, poiLon, query);

          if (places) {
            for (const place of places) {
              const lon = place.geometry.coordinates[1];
              const lat = place.geometry.coordinates[0];

              let pin = viewer.entities.add({
                name: "mapPin",
                position: Cesium.Cartesian3.fromDegrees(lon, lat, 2),
                model: {
                  uri: "./models/pin.glb",
                  heightReference: Cesium.HeightReference.RELATIVE_TO_3D_TILE,
                },
              });
            }
          }
        } catch {
          console.log("Error calling API");
        }
      }

      // View Locations
      async function Corvin(duration = 2) {
        removeEntityWithName("mapPin");
        //const place = await callAPI(47.485843084151384, 19.076113817393416, "restaurant");

        viewer.scene.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(
            19.07942624,
            47.484977,
            170
          ),
          orientation: new Cesium.HeadingPitchRoll(0, -0.49459905591668996, 0),
          duration: duration,
        });
      }

      async function Moricz(duration = 2) {
        removeEntityWithName("mapPin");
        viewer.scene.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(
            19.044429799048846,
            47.47749819582731,
            300
          ),
          orientation: new Cesium.HeadingPitchRoll(
            1.5,
            -0.49459905591668996,
            0
          ),
          duration: duration,
        });
      }

      async function Aalto(duration = 2) {
        removeEntityWithName("mapPin");
        viewer.scene.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(24.828, 60.18499, 100),
          orientation: new Cesium.HeadingPitchRoll(0, 0, 0),
          duration: duration,
        });
      }
      let agents = [];
      let spherePositions = {};

      function checkAgents() {
        for (let i = agents.length - 1; i >= 0; i--) {
          let startTime = agents[i].time;
          let endTime = new Date().getTime();
          if (endTime - startTime > 5000) {
            removeEntityWithName(agents[i].name);
            removeEntityWithName(agents[i].name + "sphere");
            removeEntityWithName(agents[i].name + "label");
            delete spherePositions[agents[i].name + "sphere"];
            agents.splice(i, 1);
          }
        }
      }

      function updateAgentTime(name) {
        for (let i = 0; i < agents.length; i++) {
          if (agents[i].name === name) {
            agents[i].time = new Date().getTime();
          }
        }
      }

      function CreateEntityWithName(entityName, lon, lat, height, rgb, name) {
        const heading = Cesium.Math.toRadians(0);
        const pitch = 0;
        const roll = 0;
        const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(
          Cesium.Cartesian3.fromDegrees(lon, lat, height),
          hpr
        );

        let axes = viewer.entities.add({
          name: entityName,
          model: { uri: "./models/axes.glb" },
          position: Cesium.Cartesian3.fromDegrees(lon, lat, height),
          orientation: orientation,
        });

        axes.model.heightReference = Cesium.HeightReference.RELATIVE_TO_3D_TILE;

        spherePositions[entityName + "sphere"] = Cesium.Cartesian3.fromDegrees(
          lon,
          lat,
          200
        );

        let sphere = viewer.entities.add({
          name: entityName + "sphere",
          position: new Cesium.CallbackProperty(function () {
            return spherePositions[entityName + "sphere"];
          }, false),
          ellipsoid: {
            radii: new Cesium.Cartesian3(0.7, 0.7, 0.7),
            material: Cesium.Color.fromBytes(rgb.r, rgb.g, rgb.b, 255),
            heightReference: Cesium.HeightReference.NONE,
          },
        });

        let label = viewer.entities.add({
          name: entityName + "label",
          position: Cesium.Cartesian3.fromDegrees(lon, lat, height + 2),
          label: {
            text: name,
            font: "14pt sans-serif",
            fillColor: Cesium.Color.WHITE,
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2,
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            heightReference: Cesium.HeightReference.RELATIVE_TO_3D_TILE,
            disableDepthTestDistance: Number.POSITIVE_INFINITY, // ensures label is always visible
          },
        });
      }

      function removeEntityWithName(entityName) {
        const entities = viewer.entities.values;

        for (let i = entities.length - 1; i >= 0; i--) {
          if (entities[i].name === entityName) {
            viewer.entities.remove(entities[i]);
          }
        }
      }

      function getTileHeightFromLatLon(lon, lat) {
        const canvas = viewer.scene.canvas;
        // Convert lat/lon to screen coordinates (approximation)
        const cartesian = Cesium.Cartesian3.fromDegrees(lon, lat);
        const screenPosition = Cesium.SceneTransforms.worldToWindowCoordinates(
          viewer.scene,
          cartesian
        );
        if (screenPosition) {
          // Get the intersection with the Google tileset mesh
          const pickedPosition = viewer.scene.pickPosition(screenPosition);

          if (Cesium.defined(pickedPosition)) {
            const cartographic =
              Cesium.Cartographic.fromCartesian(pickedPosition);
            return cartographic.height;
          } else {
            return null;
          }
        }
      }

      function updateSphere(name, lon, lat, height) {
        let sphereHeight = parseFloat(
          document.getElementById("rmqheight").value
        );
        const entities = viewer.entities.values;
        let position;
        let tileHeight = getTileHeightFromLatLon(lon, lat);
        let newHeight = height + tileHeight + 0.5;
        for (let i = 0; i < entities.length; i++) {
          if (entities[i].name === name) {
            const key = name;
            if (spherePositions[key]) {
              spherePositions[key] = Cesium.Cartesian3.fromDegrees(
                lon,
                lat,
                sphereHeight
              );
            }
            return;
          }
        }
      }

      function updateLabel(lon, lat, height, entityname) {
        const entities = viewer.entities.values;
        for (let i = 0; i < entities.length; i++) {
          if (entities[i].name === entityname) {
            entities[i].position = Cesium.Cartesian3.fromDegrees(
              lon,
              lat,
              height + 5
            );
          }
        }
      }

      function updatePosition(message) {
        const entities = viewer.entities.values;
        const entityName = message.agent_id;
        const lat = message.geopose.position.lat;
        const lon = message.geopose.position.lon;
        const height = message.geopose.position.h;
        const x = message.geopose.quaternion.x;
        const y = message.geopose.quaternion.y;
        const z = message.geopose.quaternion.z;
        const w = message.geopose.quaternion.w;
        const rgb = message.avatar.color;
        const name = message.avatar.name;

        for (let i = 0; i < entities.length; i++) {
          if (entities[i].name === entityName) {
            updateAgentTime(entityName);
            updateSphere(entityName + "sphere", lon, lat, height);
            updateLabel(lon, lat, height, entityName + "label");
            // ---------------------------------
            // GeoPose camera orientation:
            // X forward to East, Y left to North, Z up to up, and identity looking to East
            // Cesium orientation
            // X right to East, Y to North, Z up, and identity looking to North
            //-------------------------------------------------------------------------------------------
            const position = Cesium.Cartesian3.fromDegrees(lon, lat, height);
            let quatCam = new Cesium.Quaternion(x, y, z, w);
            const quatZm90 = new Cesium.Quaternion(0, 0, -0.7071068, 0.7071068); // -90 degrees rotation around Z axis
            let quatCesium = new Cesium.Quaternion();

            Cesium.Quaternion.multiply(quatCam, quatZm90, quatCesium);
            const hpr = Cesium.HeadingPitchRoll.fromQuaternion(quatCesium);
            const quatENU = Transforms.headingPitchRollQuaternion(
              position,
              hpr
            );

            entities[i].position = position;
            entities[i].orientation = quatENU;
            entities[i].model.heightReference =
              Cesium.HeightReference.RELATIVE_TO_3D_TILE;
            //----------------------------------------------------------------------------------------------------------
            return;
          }
        }

        agents.push({
          name: entityName,
          time: new Date().getTime(),
        });
        CreateEntityWithName(entityName, lon, lat, height, rgb, name);
      }
      setInterval(checkAgents, 1000);
      Corvin(0);
      window.Corvin = Corvin;
      window.Moricz = Moricz;
      window.connectRMQ = connectRMQ;
      window.searchForPOIS = searchForPOIS;
      window.Localize = Localize;
      window.Go = Go;
      window.Aalto = Aalto;

      const toolbarSelect = document.getElementById("toolbarSelect");
      const toolbars = [
        document.getElementById("toolbar"),
        document.getElementById("toolbar1"),
        document.getElementById("toolbar2"),
        document.getElementById("MapAligner"),
      ];

// ----------------------------------------
// 3D MODEL HANDLING IN MAPALIGNER (FIXED)
// ----------------------------------------

let models = {};
let selectedModel = null;
let modelCounter = 0;

// ==============================
// FILE UPLOAD HANDLER
// ==============================
document.getElementById("modelFileInput").addEventListener("change", (event) => {
  const file = event.target.files[0];
  if (!file) return;

  const url = URL.createObjectURL(file);
  loadModel(url, true);
});

// ==============================
// SCALE
// ==============================
document.getElementById("modelScale").addEventListener("change", (event) => {
  selectedModel.scale = document.getElementById("modelScale").value;
  updateModelTransform(selectedModel);
});

// ==============================
// LOAD MODEL FROM USER-ENTERED URL
// ==============================
window.loadModelFromURL = function () {
  const url = document.getElementById("modelUrl").value.trim();
  if (url) {
    loadModel(url);
  } else {
    alert("Please enter a valid model URL!");
  }
};

// ==============================
// MAIN MODEL LOADER
// ==============================
function loadModel(modelUrl, revokeAfter = false) {
  if (typeof mapLongitude === "undefined" || typeof mapLatitude === "undefined" || typeof mapHeight === "undefined") {
    alert("Map coordinates are not defined!");
    return;
  }

  const position = Cesium.Cartesian3.fromDegrees(mapLongitude, mapLatitude, mapHeight);
  const hpr = new Cesium.HeadingPitchRoll(0, 0, 0);
  const modelName = "userModel_" + modelCounter++;

  const entity = viewer.entities.add({
    name: modelName,
    position: position,
    orientation: Cesium.Transforms.headingPitchRollQuaternion(position, hpr),
    model: {
      uri: modelUrl,
      scale: 1.0,
      minimumPixelSize: 0,
    },
  });

  // New extended model object
  const modelObj = {
    name: modelName,
    startPosition: {lat: mapLatitude, lon: mapLongitude},
    entity,
    position,
    heading: 0,
    pitch: 0,
    roll: 0,
    translation: { x: 0, y: 0, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 1.0,
    matrix: [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ],
  };

  models[modelName] = modelObj;
  selectedModel = modelObj;

  if (revokeAfter) {
    setTimeout(() => URL.revokeObjectURL(modelUrl), 5000);
  }

  console.log(`Model loaded: ${modelName}`);
}

// ==============================
// MODEL SELECTION (CLICK HANDLER)
// ==============================
const modelClickHandler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

modelClickHandler.setInputAction((click) => {
  const picked = viewer.scene.pick(click.position);

  if (Cesium.defined(picked) && picked.id && models[picked.id.name]) {
    selectedModel = models[picked.id.name];
    console.log("Selected model:", selectedModel.name);
  } else {
    selectedModel = null;
    console.log("No model selected");
  }
}, Cesium.ScreenSpaceEventType.LEFT_CLICK);

// ==============================
// MOVEMENT CONTROLS
// ==============================
window.moveModel = function (direction) {
  if (!selectedModel) return alert("No model selected!");

  const carto = Cesium.Cartographic.fromCartesian(selectedModel.position);
  const latLonStep = parseFloat(document.getElementById("positionStep").value/1000000) || 10;
  const heightStep = parseFloat(document.getElementById("heightStep").value) || 1;

  switch (direction) {
    case "north": carto.latitude += Cesium.Math.toRadians(latLonStep); break;
    case "south": carto.latitude -= Cesium.Math.toRadians(latLonStep); break;
    case "east":  carto.longitude += Cesium.Math.toRadians(latLonStep); break;
    case "west":  carto.longitude -= Cesium.Math.toRadians(latLonStep); break;
    case "up":    carto.height += heightStep; break;
    case "down":  carto.height -= heightStep; break;
  }

  selectedModel.position = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, carto.height);
  updateModelTransform(selectedModel);
};

// ==============================
// ROTATION CONTROLS
// ==============================
function getRotationStep() {
  return Cesium.Math.toRadians(parseFloat(document.getElementById("rotationStep").value) || 5);
}

// Rotate Heading (Yaw)
window.rotateModel = function (direction) {
  if (!selectedModel) return alert("No model selected!");
  const step = getRotationStep();
  selectedModel.heading += (direction === "left" ? -step : step);
  updateModelTransform(selectedModel);
};

// Adjust Pitch
window.adjustPitch = function (direction) {
  if (!selectedModel) return alert("No model selected!");
  const step = getRotationStep();
  selectedModel.pitch += (direction === "up" ? step : -step);
  updateModelTransform(selectedModel);
};

// Adjust Roll
window.adjustRoll = function (direction) {
  if (!selectedModel) return alert("No model selected!");
  const step = getRotationStep();
  selectedModel.roll += (direction === "right" ? step : -step);
  updateModelTransform(selectedModel);
};

// ==============================
// TRANSFORM UPDATER
// ==============================
function updateModelTransform(modelObj) {
  if (!modelObj || !modelObj.entity) return;

  // Ensure numeric radians
  const heading = Number(modelObj.heading) || 0;
  const pitch = Number(modelObj.pitch) || 0;
  const roll = Number(modelObj.roll) || 0;

  // Update Cesium orientation
  const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
  modelObj.entity.position = modelObj.position;
  modelObj.entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(modelObj.position, hpr);
  modelObj.entity.model.scale = modelObj.scale;

  // Approximate translation in local tangent plane (for logging/export)
  const carto = Cesium.Cartographic.fromCartesian(modelObj.position);
  const R = 6378137.0; // WGS84 mean Earth radius

  const refLat = Cesium.Math.toRadians(mapLatitude);
  const refLon = Cesium.Math.toRadians(mapLongitude);
  const curLat = carto.latitude;
  const curLon = carto.longitude;

  const dLat = curLat - refLat;
  const dLon = curLon - refLon;

  const x = dLon * R * window.Math.cos(refLat); // East (meters)
  const y = dLat * R;                           // North (meters)
  const z = carto.height - mapHeight;           // Up (meters)

  modelObj.translation = { x, y, z };

  // Store rotation in degrees (for readability)
  modelObj.rotation = {
    x: Cesium.Math.toDegrees(pitch),
    y: Cesium.Math.toDegrees(roll),
    z: Cesium.Math.toDegrees(heading),
  };

  // Compute rotation * scale matrix (Heading–Pitch–Roll order)
  const cosH = window.Math.cos(heading);
  const sinH = window.Math.sin(heading);
  const cosP = window.Math.cos(pitch);
  const sinP = window.Math.sin(pitch);
  const cosR = window.Math.cos(roll);
  const sinR = window.Math.sin(roll);
  const s = Number(modelObj.scale) || 1.0;

  // Cesium HPR rotation order: heading (Z), pitch (X), roll (Y)
  const m11 = s * (cosH * cosR + sinH * sinP * sinR);
  const m12 = s * (sinR * cosP);
  const m13 = s * (-sinH * cosR + cosH * sinP * sinR);
  const m21 = s * (-cosH * sinR + sinH * sinP * cosR);
  const m22 = s * (cosR * cosP);
  const m23 = s * (sinR * sinH + cosH * sinP * cosR);
  const m31 = s * (sinH * cosP);
  const m32 = s * (-sinP);
  const m33 = s * (cosH * cosP);

  modelObj.matrix = [
    [m11, m12, m13, modelObj.translation.x],
    [m21, m22, m23, modelObj.translation.y],
    [m31, m32, m33, modelObj.translation.z],
    [0, 0, 0, 1],
  ];

  // Optional debug
  console.log("Updated transform for", modelObj.name, modelObj.matrix);
}

// ==============================
// UTILITY FUNCTIONS
// ==============================
window.getHeightStep = function () {
  return parseFloat(document.getElementById("heightStep").value) || 1;
};

window.exportModelMatrix = async function () {
  if (!selectedModel) {
    alert("No model selected!");
    return;
  }

  const json = {
    latitude: selectedModel.startPosition.lat,
    longitude: selectedModel.startPosition.lon,
    height: mapHeight,
    matrix: selectedModel.matrix
  };

  const jsonString = JSON.stringify(json, null, 2);
  const fileName = selectedModel.name + "_matrix.json";

  // Check browser support
  if (window.showSaveFilePicker) {
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName: fileName,
        types: [
          {
            description: "JSON file",
            accept: { "application/json": [".json"] }
          }
        ]
      });

      const writable = await handle.createWritable();
      await writable.write(jsonString);
      await writable.close();

      console.log("Saved JSON using showSaveFilePicker.");
      return;
    } catch (error) {
      console.warn("showSaveFilePicker failed, falling back:", error);
    }
  }

  // Fallback: old behavior ("Save As..." dialog)
  const blob = new Blob([jsonString], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = fileName;
  a.click();

  URL.revokeObjectURL(url);
};

// ==============================
// DELETE SELECTED MODEL
// ==============================
window.deleteSelectedModel = function () {
  if (!selectedModel) {
    alert("No model selected!");
    return;
  }

  const confirmDelete = confirm(`Delete model "${selectedModel.name}"?`);
  if (!confirmDelete) return;

  // Remove from Cesium viewer
  viewer.entities.remove(selectedModel.entity);

  // Remove from models dictionary
  delete models[selectedModel.name];

  console.log(`Deleted model: ${selectedModel.name}`);
  selectedModel = null;
};

document.addEventListener("keydown", (e) => {
  if ((e.key === "Delete") && selectedModel) {
    deleteSelectedModel();
  }
});

  await handleRedirect();

  const user = await getUserInfo();

  if (user) {
    console.log("User logged in:", user);
    document.getElementById("loginBtn").style.display = "none";
    document.getElementById("logoutBtn").style.display = "block";
  } else {
    console.log("User not logged in");
    document.getElementById("loginBtn").style.display = "block";
    document.getElementById("logoutBtn").style.display = "none";
  }

  window.login = login;
  window.logout = logout;


  async function loadMap() {
  try {
    const transform = await getTransform("map123", "hloc45", "dataset001");
    console.log("Transform JSON:", transform);
  } catch (e) {
    console.error(e);
  }
}

async function saveMatrix(selectedModel) {
  const payload = {
    latitude: selectedModel.startPosition.lat,
    longitude: selectedModel.startPosition.lon,
    height: mapHeight,
    matrix: selectedModel.matrix
  };

  try {
    const result = await postTransform("map123", "hloc45", "dataset001", payload);
    console.log("Saved transform:", result);
  } catch (e) {
    console.error(e);
  }
}

      // Hide all toolbars initially
      toolbars.forEach((tb) => (tb.style.display = "none"));

      toolbarSelect.addEventListener("change", function () {
        // Hide all toolbars
        toolbars.forEach((tb) => (tb.style.display = "none"));

        // Show only the selected one
        if (this.value) {
          document.getElementById(this.value).style.display = "block";
        }
      });
    </script>
  </body>
</html>
